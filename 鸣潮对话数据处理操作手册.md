# 鸣潮对话数据处理操作手册

## 数据准备指南

### 📁 原始数据文件
处理前需要确保以下文件存在：
- `WutheringDialog/data/dialogs_zh-Hans.jsonl` (原始对话数据)
- `ConfigDB/PlotHandBookConfig.json` (剧情配置)
- `ConfigDB/QuestNodeData.json` (任务节点数据)
- `TextMap/zh-Hans/MultiText.json` (文本映射)

### 🔄 生成Split数据
**问题**: 没有 `dialogs_zh-Hans.split.jsonl` 文件

**解决方案**:
```bash
python generate_split_data.py
```

这个脚本会：
- 自动查找原始数据文件
- 解析对话doc_id
- 提取flow信息
- 生成split格式数据

### 🔍 检查原始数据
```bash
python generate_split_data.py check
```

## 紧急情况处理指南

### 🚨 一键修复（推荐）
**问题**: 数据出问题了，需要快速修复

**解决方案**:
```bash
python one_click_fix.py
```

这个脚本会自动：
- 检查所有必要文件
- 备份现有结果
- 扫描数据模式
- 重新处理数据
- 质量检查
- 生成修复报告

### 场景1：游戏更新后需要增量更新
**问题**: 库洛更新了游戏，新增了对话数据，需要处理新数据

**解决方案**:
```bash
python incremental_update.py
```

这个脚本会自动：
- 检查原始数据是否有更新
- 比较文件大小和时间戳
- 备份当前结果
- 重新处理数据
- 验证结果质量

### 场景2：快速诊断问题
**问题**: 不知道数据出了什么问题

**解决方案**:
```bash
python emergency_diagnosis.py
```

这个脚本会检查：
- 文件完整性
- 数据格式正确性
- 快速质量指标
- 提供修复建议

### 场景3：强制修复
**问题**: 数据完全坏了，需要从头开始

**解决方案**:
```bash
python one_click_fix.py fix
```

这会强制重新处理所有数据。

### 场景2：从零开始重新处理
**问题**: 原始数据损坏或需要完全重新处理

**解决步骤**:
1. **检查原始数据完整性**
   ```bash
   # 检查所有必要的配置文件
   ls -la ConfigDB/PlotHandBookConfig.json
   ls -la ConfigDB/QuestNodeData.json
   ls -la TextMap/zh-Hans/MultiText.json
   ls -la WutheringDialog/data/dialogs_zh-Hans.split.jsonl
   ```

2. **验证数据格式**
   ```bash
   # 检查JSON格式是否正确
   head -5 WutheringDialog/data/dialogs_zh-Hans.split.jsonl | python -m json.tool
   ```

3. **运行完整处理流程**
   ```bash
   python complete_dialogue_processor.py
   ```

4. **质量检查**
   ```bash
   python analyze_final_quality.py
   ```

5. **如果质量不达标，运行诊断**
   ```bash
   python auto_scan_categories.py
   ```

## 故障排除指南

### 问题1：映射率低于80%
**症状**: 处理完成后映射率只有60-70%

**诊断步骤**:
1. **检查配置文件是否更新**
   ```bash
   # 检查PlotHandBookConfig.json行数
   wc -l ConfigDB/PlotHandBookConfig.json
   # 应该接近59行
   
   # 检查QuestNodeData.json行数  
   wc -l ConfigDB/QuestNodeData.json
   # 应该接近14,717行
   ```

2. **运行扫描脚本找出新pattern**
   ```bash
   python auto_scan_categories.py
   ```

3. **手动添加新分类**
   - 打开 `complete_dialogue_processor.py`
   - 在相应的分类字典中添加新的flow pattern
   - 重新运行处理

### 问题2：大量Unknown分类
**症状**: 最终结果中还有大量Unknown

**解决步骤**:
1. **找出Unknown的pattern**
   ```bash
   # 在analyze_final_quality.py中添加代码
   grep -o '"quest_name": "Unknown"' WutheringDialog/data/dialogs_zh-Hans.complete_final.jsonl | wc -l
   ```

2. **分析Unknown的doc_id模式**
   ```bash
   # 提取Unknown记录的doc_id
   grep '"quest_name": "Unknown"' WutheringDialog/data/dialogs_zh-Hans.complete_final.jsonl | head -20
   ```

3. **更新分类系统**
   - 根据新的pattern更新分类字典
   - 重新运行处理

### 问题3：章节信息缺失严重
**症状**: Chapter Title覆盖率低于30%

**解决步骤**:
1. **检查QuestId推断逻辑**
   - 打开 `complete_dialogue_processor.py`
   - 检查 `infer_chapter_id` 函数
   - 根据新的QuestId范围更新推断规则

2. **手动添加章节映射**
   ```python
   # 在main_story_categories中添加新的章节映射
   '新章节pattern': {'chapter': '新章节名', 'section': '新章节内容'},
   ```

## 日常维护操作

### 每周检查
1. **数据质量监控**
   ```bash
   python analyze_final_quality.py
   ```

2. **检查是否有新的Unknown pattern**
   ```bash
   grep '"quest_name": "Unknown"' WutheringDialog/data/dialogs_zh-Hans.complete_final.jsonl | wc -l
   ```

### 每月维护
1. **备份所有处理脚本**
   ```bash
   tar -czf processing_scripts_$(date +%Y%m%d).tar.gz *.py
   ```

2. **更新分类系统**
   - 运行 `auto_scan_categories.py`
   - 根据结果更新分类字典
   - 重新处理数据

## 性能优化

### 处理大文件时
1. **分批处理**
   ```python
   # 在complete_dialogue_processor.py中修改批处理大小
   batch_size = 10000  # 每批处理1万条
   ```

2. **内存优化**
   ```python
   # 使用生成器而不是列表
   def process_dialogues_generator(file_path):
       with open(file_path, 'r', encoding='utf-8') as f:
           for line in f:
               yield json.loads(line.strip())
   ```

### 调试模式
1. **启用详细日志**
   ```python
   import logging
   logging.basicConfig(level=logging.DEBUG)
   ```

2. **保存中间结果**
   ```python
   # 在处理过程中保存中间结果
   if i % 10000 == 0:
       with open(f'intermediate_result_{i}.jsonl', 'w') as f:
           # 保存当前批次的结果
   ```

## 紧急修复流程

### 数据损坏时
1. **立即停止处理**
2. **恢复备份**
   ```bash
   cp WutheringDialog/data/dialogs_zh-Hans.complete_final.jsonl.backup WutheringDialog/data/dialogs_zh-Hans.complete_final.jsonl
   ```

3. **检查原始数据**
   ```bash
   # 验证原始文件完整性
   python -c "import json; [json.loads(line) for line in open('WutheringDialog/data/dialogs_zh-Hans.split.jsonl')]"
   ```

4. **重新处理**
   ```bash
   python complete_dialogue_processor.py
   ```

## 版本控制

### Git工作流
1. **处理前提交**
   ```bash
   git add .
   git commit -m "Before processing update"
   ```

2. **处理后提交**
   ```bash
   git add WutheringDialog/data/dialogs_zh-Hans.complete_final.jsonl
   git commit -m "Processed dialogue data - $(date)"
   ```

3. **标签重要版本**
   ```bash
   git tag -a v1.0 -m "Stable processing version"
   ```

## 监控脚本

### 自动化质量检查
```python
#!/usr/bin/env python3
# monitor_quality.py

import subprocess
import json
from datetime import datetime

def check_quality():
    result = subprocess.run(['python', 'analyze_final_quality.py'], 
                          capture_output=True, text=True)
    
    # 解析结果
    lines = result.stdout.split('\n')
    for line in lines:
        if '成功映射:' in line:
            mapping_rate = float(line.split('(')[1].split('%')[0])
            if mapping_rate < 80:
                print(f"WARNING: Mapping rate {mapping_rate}% is below 80%")
                return False
    
    print("Quality check passed")
    return True

if __name__ == "__main__":
    check_quality()
```

## 常见错误及解决方案

### 错误1: JSON解析错误
```
json.JSONDecodeError: Expecting value: line 1 column 1
```
**解决**: 检查文件编码，确保是UTF-8

### 错误2: 内存不足
```
MemoryError: Unable to allocate array
```
**解决**: 使用分批处理或增加虚拟内存

### 错误3: 文件权限错误
```
PermissionError: [Errno 13] Permission denied
```
**解决**: 检查文件权限，确保有写入权限

---

## 脚本使用说明

### 核心脚本列表
1. **generate_split_data.py** - 生成Split数据脚本（第一步）
2. **one_click_fix.py** - 一键修复脚本（推荐）
3. **incremental_update.py** - 增量更新脚本
4. **emergency_diagnosis.py** - 紧急诊断脚本
5. **auto_scan_categories.py** - 自动扫描分类脚本
6. **complete_dialogue_processor.py** - 完整处理器
7. **analyze_final_quality.py** - 质量分析脚本

### 常用命令
```bash
# 第一步：生成Split数据（如果没有的话）
python generate_split_data.py

# 检查原始数据
python generate_split_data.py check

# 一键修复（最常用）
python one_click_fix.py

# 增量更新
python incremental_update.py

# 快速诊断
python emergency_diagnosis.py

# 强制修复
python one_click_fix.py fix

# 快速扫描
python one_click_fix.py scan

# 检查配置更新
python incremental_update.py check

# 质量检查
python incremental_update.py quality
```

### 脚本功能对比
| 脚本 | 用途 | 适用场景 | 运行时间 |
|------|------|----------|----------|
| generate_split_data.py | 生成Split数据 | 缺少split文件 | 2-3分钟 |
| one_click_fix.py | 一键修复 | 数据出问题 | 5-10分钟 |
| incremental_update.py | 增量更新 | 游戏更新 | 3-5分钟 |
| emergency_diagnosis.py | 快速诊断 | 不知道问题 | 30秒 |
| auto_scan_categories.py | 扫描分类 | 需要更新分类 | 1-2分钟 |
| complete_dialogue_processor.py | 完整处理 | 从头处理 | 5-10分钟 |
| analyze_final_quality.py | 质量分析 | 检查结果 | 1分钟 |

**重要提醒**: 
- 每次处理前都要备份
- 处理大文件时使用分批处理
- 定期检查数据质量
- 保持脚本的版本控制
- 遇到问题先运行诊断脚本
- 优先使用一键修复脚本
